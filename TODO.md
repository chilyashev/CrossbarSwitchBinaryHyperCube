# План за действие.


1. Инициализация *check*
    1. Input/Output channels *check*
        1. RRA *check*
        2. FIFOQueues *check*
            1. Arbiters (lil' arby guys) *check*
    2. SMPNode *check*
    3. MPPNetwork *check*
2. Генериране на тестови данни *check*
    0. Бернули.
    1. Съобщения
        1. По 1 пакет
        2. По 2 пакета
        3. По 4 пакета
        4. По 3 пакета
        5. По 5 пакета
    2. DMA-тата!
        1. Да се случва нещо, когато нещо се получи напълно *check?*
3. Статистика
    1. Graphics


4. Да се провери дали всички сигнали се зануляват, когато трябва. *check*


- Изчисляване на всички сигнали, които зависят от сигнали на други чаркове (PACK_WAIT например) *check*
        - WR_IN_FIFO

5. Да видим защо FIFO_BUSY не се сваля никога и как, по дяволите, входният канал ще си ходи из състоянията, след като всичките му опашки са винаги заети *check*

6. Изпращането на съобщения **трябва** да се направи. *check*





~Рутирането се маже. В RRA grant-а не работи правилно.~


~1. Първо се вика calculateState за всички елементи, след това се вика tick()!~


~да проследим в лога състоянията на изходния канал след изпращането на целия пакет (защото се опитва да праща null-ове)~





1. ~Каналите~ Връзките между възлите да се рисуват двупосочни *check*
    1. Всеки възел да има цвят, в който ще се изобразяват всички пакети
    2. Маршрутите да се засветяват *check*
2. Графика на латентност
    1. x = ?, y = латентност?
3. Step by step да рисува и 8 възела _|_
4. Времето за работа на модела е в тактове (до 100 000)
5. Bursty режим за генериране на съобщения
6. Генерирането на съобщения да е за някакъв интервал (100 такта например)
7. Системни пакети
    1. Състоят се от заглавен флит и краен флит. Или пък само от краен

----
2016-08-20

1. Да се запазва какво е избрано за последната симулация.
2. Read-only полетата да станат не-read-only
3.

За статистиката:

 1. Времезадръжки (bouncin)
 2. Master baiting (кога са пристигнали пакетите)